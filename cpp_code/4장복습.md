그리디 알고리즘은 매 순간 최선만을 선택하여 해를 구성하는 방법이다
지역 최적 해를 선택하기 때문에 그리디로 구한 해가 전역최적인지는 증명이 필요하다

예시 - 거스름돈 문제 (개수 최소화)
그리디 알고리즘
매 순간 최고 고액권으로만 많이 주면 개수가 최소화된다

일반적으로 그리디 알고리즘의 절차는 아래와 같다
1. 최적 선택 (주어진 상황에서 가장 최적의 선택을 한다)
2. 선택 검증 (선택된 것이 해의 구성 조건을 위반하는지 확인)
3. 해 검증 (2의 모음이 해를 구성하는지 판별, 해가 되지 않으면 1로 돌아감)

그리디 알고리즘으로 풀 수 있는 문제

최소신장트리문제
주어진 무향 가중 그래프 $G(V, E)$ 에 대해 가중치의 합이 최소화되는 부분그래프 트리인 $T(V, E')$ 를 구하는 문제

그리디 알고리즘 : 프림, 크루스칼

프림 알고리즘
최소신장트리는 부분그래프이므로 어느 노드에서 시작하든 상관없다
$V_1$ 에서 출발하여 가장 가까운 인접노드를 택해 트리 구성

의사코드
```python
def prim(G(V_g, E_g)):
    value, V, E = 0, {}, {}
    while V != V_g:
        mini, V_min, E_app = inf, None, None
        for i in V:
            for j in V_g - V:
                if dist(i, j) < mini:
                    mini, V_min, E_app = dist(i, j), j, i
        result += mini
        V.append(V_min)
        E.append((V_min, E_app))
    return result, E
```

# Prim 알고리즘 최적성 증명 (Markdown 정리본)

> **목표**  
> 프림(Prim) 알고리즘이 출력하는 간선 집합 `F` 가 항상 **최소 신장 트리(MST)** 가 됨을 보인다.

---

## 1 선행 정의·표기

| 기호 | 의미 |
|------|------|
| `G = (V, E, w)` | 연결 가중치 그래프, `w(e) > 0` |
| `F_k` | 프림 알고리즘이 **k 번째 단계**까지 선택한 간선 집합 |
| `S_k` | 그때까지 선택된 **정점 집합** (루트 포함) |
| `cut(S, V\S)` | `S_k` 와 `V\S_k` 를 분리하는 컷 |
| **safe edge** | 어떤 컷을 가로지르면서, 해당 컷에서 **최소 가중치** 인 간선 |

**Cut Property**  
 컷을 가로지르는 최소 가중치 간선은 *항상* 어떤 MST 에 포함될 수 있다.  
 ⇒ safe edge 는 **유망(promising)** 하다.

---

## 2 귀납적 증명(Induction on k)

### 2.1 귀납 가설

> **P(k)** : 단계 *k* 종료 시 간선 집합 `F_k` 는 **일부 MST 의 부분집합**이다.

### 2.2 기초 단계 *(k = 0)*

`F_0 = ∅` 이므로 trivially P(0) 성립.

### 2.3 귀납 단계

*가정* P(k) 가 성립한다고 하자.  
단계 *k+1* 에서 프림은 컷 `cut(S_k, V\S_k)` 를 고려하고, 그 컷을 가로지르는 **최소 가중치** 간선 `e = (u,v)` 를 선택한다.

#### Case 1 `e ∈ E*` (어떤 MST 에 이미 포함)

- 귀납 가설로부터 `F_k ⊆ E*`.  
- 따라서 `F_{k+1} = F_k ∪ {e} ⊆ E*`.  
- 즉 P(k+1) 성립.

#### Case 2 `e ∉ E*`

> 여기서 **사이클 교체(Cycle‑Exchange)** 논증 사용

1. `E* ∪ {e}` 는 간선 수가 |V| 이므로 정확히 **사이클 하나**를 포함.  
2. 그 사이클 안에는 `e ≠ e'∈E*` 이면서 역시 컷을 가로지르는 간선 `e'` 이 존재.  
3. 컷 property에 의해 `w(e) ≤ w(e')`.  
4. 집합 `E' = E* ∪ {e} − {e'}` 는  
   * (i) |V|−1 개의 간선을 가지며  
   * (ii) 사이클이 제거되어 **스패닝 트리**가 되고  
   * (iii) 가중치 `w(E') = w(E*) + w(e) − w(e') ≤ w(E*)`  
   ⇒ `E'` 역시 MST 가 된다.  
5. 또한 `F_{k+1} = F_k ∪ {e} ⊆ E'`. 따라서 P(k+1) 성립.

두 경우 모두 P(k+1) 이 참이므로 귀납 완료.

### 2.4 종결

`k = |V|−1` 단계에서 `F_{|V|−1}` 는  
* (i) **스패닝 트리**이고  
* (ii) 어떤 MST 와 동일한 가중치를 가진다.  

따라서 프림 알고리즘의 출력 `F` 는 최소 신장 트리.

---

## 3 요약 메모

* **safe edge = promising edge** (컷 최소 간선).  
* 프림은 매 단계 safe edge 만 선택 → 부분해가 항상 MST 부분집합.  
* 귀납 + 교체 논증으로 최종해도 MST 임을 보장. 🚩

프림은 어떤 집합과 인접한 노드중 가장 작은 엣지를 고른다

크루스칼 알고리즘

엣지들을 선택해나가며 해를 구성한다

0. 결과는 공집합에서 시작
1. 엣지를 가중치 순으로 정렬한다
2. 앞의 것을 결과에 넣는다
4. 


크루스칼 전역 최적 증명

크루스칼의 임의 단계 출력 $F_{i} \in G(E)$ 가 항상 기대집합임을 보이면 된다
각 단계에 대해 수학적 귀납법으로 증명한다

기저
공집합은 기대집합이므로 시작단계는 기대집합이다

귀납가설
$k$ 단계 출력 $F_{k}$ 이 기대집합이라고 가정

귀납단계

크루스칼 알고리즘의 작동 원리에 의해
$k+1$ 단계에서 선택되는 $e$ 는 아래를 만족
1. $F_k \cup \{e\}$ 는 사이클이 없음
2. $e$ 는 1을 만족하는 동시에 $G(E) - F_k$ 의 간선 중 가장 가중치가 작은 간선

귀납가정에 의해
$F_k$ 는 기대집합이므로 $\exists F',F_k \cup F' \text{ is MST}$

1. $e \in F'$
$MST = F_k \cup F' = F_k \cup \{e\} \cup (F' - \{e\}) = F_{k+1} \cup (F' - \{e\})$
따라서 $F_{k+1}$ 은 기대집합

2. $e \notin F'$
$F_{k} \cup \{e\} \cup F'$ 은 사이클이 유일한 그래프이다 간선 수는 $n = |G(V)|$ 이고
$e$ 는 $F_k \cup \{e\}$ 는 사이클이 없음을 만족
$F' \subseteq G(E) - F_k$ 이므로
$e'$ 를 제거시 $F_{k} \cup \{e\} \cup F'$ 에서 사이클이 없어지는 $e' \in F'$ 가 존재
$e$ 는 $G(E) - F_k$ 에서 가장 가중치가 작은 간선이므로 $e \le e'$ 이다
따라서 $F_{k} \cup \{e\} \cup (F' - \{e'\}) = F_{k+1} \cup (F' - \{e'\})$ 는 최소신장트리이다

모든 경우에 대해 $F_{k+1}$ 이 기대집합이므로 수학적귀납법에 의해 모든 단계는 기대집합이다

크루스칼의 알고리즘은 한 단계시 엣지를 하나 선택하고
엣지가 $n-1$ 개 선택시 종료되므로 최종출력은 엣지가 $n-1$ 개인 기대집합이다
이는 트리의 정의와 기대집합의 정의에 의해 가장 크기가 큰 기대집합이므로 즉
최종출력은 최소신장트리이다


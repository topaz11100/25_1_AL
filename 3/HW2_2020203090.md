## HW3 보고서 2020203090 한용옥
## 실행환경
### 언어 : `c++20`
### 컴파일러 및 IDE : Microsoft Visual Studio Community 2022 버전 17.13.6

## 퍼즐 모델링 방법 및 텍스트 표현

### 퍼즐의 기본 구조

제공된 퍼즐은 3x3 크기의 격자로 구성되어 있으며 각 칸에는 퍼즐 조각이 배치된다
각 퍼즐 조각은 네 방향(북, 서, 남, 동)에 그림이 있으며
이 그림들이 인접한 조각의 그림과 맞아떨어져야 퍼즐이 완성된다

### 그림 종류와 분할 방식

#### 그림 종류
조각에는 총 4종류의 그림이 사용되며 이를 알파벳 `A, B, C, D`로 모델링하였다

#### 분할 방식
각 그림은 두 가지 방식으로 분할될 수 있다
1. **위/아래 분할** : 그림이 위쪽과 아래쪽으로 나뉘어짐
2. **좌/우 분할** : 그림이 왼쪽과 오른쪽으로 나뉘어짐

### 16가지 표식

그림 4종류(`A, B, C, D`)와 분할 방식 2가지(위/아래, 좌/우)를 조합하면
총 16가지의 서로 다른 표식이 가능하다
이를 텍스트로 모델링하기 위해 다음과 같은 표기법을 사용하였다

1. 그림 종류는 알파벳(A, B, C, D)으로 표시
2. 분할 방식과 위치는 특수 기호로 표시
    |  | 위쪽 | 아래쪽 | | 왼쪽| 오른쪽|
    |--:|:--:|:--:|--:|:--:|:--:|
    | 위 아래 분할 | `+` | `-` | 좌 우 분할 | `*` | `/` |


따라서 16가지 표식은 다음과 같이 구성
- `A+, A-, A/, A*`
- `B+, B-, B/, B*`
- `C+, C-, C/, C*`
- `D+, D-, D/, D*`

### 퍼즐 텍스트열 구성법

퍼즐의 각 조각은 4개의 방향(북, 서, 남, 동)을 가지며, 각 방향에는 위에서 설명한 16가지 표식 중 하나가 배치된다
퍼즐 조각들을 텍스트로 표현할 때는 다음과 같은 규칙을 따른다

1. 각 퍼즐 조각은 한 줄로 표현됨
2. 한 줄에는 4개의 표식이 순서대로 나열(북, 서, 남, 동 방향 순)
3. 각 표식은 그림 종류(알파벳)와 분할 기호로 구성됨

예를 들어 첫 번째 퍼즐의 `0` 번째 조각은 다음과 같이 표현된다
### `A* B* B/ C*`

이는 다음을 의미한다
- 북쪽 방향: `A*` (`A` 그림의 오른쪽 부분)
- 서쪽 방향: `B*` (`B` 그림의 오른쪽 부분)
- 남쪽 방향: `B/` (`B` 그림의 왼쪽 부분)
- 동쪽 방향: `C*` (`C` 그림의 오른쪽 부분)

### 본 퍼즐의 텍스트화

(이미지로 채우기)

### 퍼즐 매칭 규칙

퍼즐을 맞추기 위해 인접한 두 조각의 맞닿는 면의 그림들은 짝이 맞아야 한다
짝이 맞음은 다음 두 조건을 모두 만족함을 의미한다

1. 그림 종류(알파벳)가 동일
2. 분할 기호가 서로 짝이어야 함
   - `+`와 `-`는 서로 짝이다(위/아래 분할의 위쪽과 아래쪽)
   - `/`와 `*`는 서로 짝이다(좌/우 분할의 왼쪽과 오른쪽)

예시
- A+는 A-와 짝이다
- B/는 B*와 짝이다
- C+는 C-와 짝이다
- D/는 D*와 짝이다

## 풀이 및 코드 분석

### 상수 및 방향 정의

|상수|값|설명|
|:--:|:--:|:--|
|`N`,`W`,`S`,`E`|`0`,`1`,`2`,`3`|퍼즐 조각의 네 방향(북, 서, 남, 동)을 나타내는 인덱스|
|`PUZ_ROW`,`PUZ_COL`|`3`,`3`|퍼즐의 행과 열 크기|
|`PIECE_COUNT`|9|퍼즐 조각의 총 개수|
|`PAINT_COUNT`|16|가능한 표식의 총 개수|
|`PAINT_TYPE`|2|각 표식의 구성 요소 수(알파벳과 기호, 2개)|
|`PAINT_CONTAIN`|4|각 조각이 가진 그림의 수(4면)|
|`SHIFT_TYPE`|4|회전 가능한 방향의 수(90도씩 4방향)|

### 퍼즐 조각 표현

퍼즐 조각을 아래의 클래스로 표현하였다

```cpp
class piece {
public:
    piece();

    void set_number(int n);
    void set_state(int s_idx, char first, char second);
    
    int get_number();
    size_t get_shift_count();
    const array<char, PAINT_TYPE>& get_state(size_t direction);
    
    void shift();
private:
    int number;
    size_t shift_count;
    array<array<array<char, PAINT_TYPE>, PAINT_CONTAIN>, SHIFT_TYPE> state;
};
```

### 필드

#### `number`
몇 번 째 조각인지 저장한다

#### `shift_count`
몇 번 반시계 회전했는지 저장한다

#### `state`
퍼즐 조각의 그림 표식을 저장하는 3차원 배열
- 첫 번째 차원: 회전 상태(`0 ~ 3`)
- 두 번째 차원: 방향(북, 서, 남, 동)
- 세 번째 차원: 그림 표식 구성 요소(알파벳과 기호)

회전된 모든 상태를 미리 계산하여 저장함으로써 실행 시간에 회전 계산을 반복하지 않게
위 배열에 상태를 저장하였다

### 메서드

#### `set_number(int n)` 
클래스 필드 설정함수이다 `number`를 설정한다

#### `get_number()` `get_shift_count()`
클래스 필드를 가져오는 함수이다 `number`, `shift_count`를 가져온다

#### `set_state(int s_idx, char first, char second)`
`s_idx` 는 동서남북 중 하나이다 표식을 받아 `state`의 `s_idx`방향 자리 원소로 설정한다
`state`는 3차원 배열로 미리 모든 회전의 결과를 갖는데
이 함수는 모든 회전 경우에 맞는 인덱스에 `first`, `second`로 만든 표식을 저장한다

#### `shift()`  `get_state(size_t direction)`
`shift` 는 필드 `shift_count`를 증가시킨다 따라서 회전한 것 같은 효과를 준다
`get_state`는 `shift_count`에 맞게 회전된 상황에서 `direction` 방향의 그림을 가져온다
`state` 에는 모든 회전 한 결과가 기록되어있으므로 `shift_count` 에 맞게 가져온다

### 조각 배열, 퍼즐 배열 표현

퍼즐 조각과 퍼즐 보드를 표현하기 위해 전역 배열을 사용

```cpp
array<piece, PIECE_COUNT> piece_arr;
array<array<piece*, PUZ_COL>, PUZ_ROW> puzzle;
```

`piece_arr` 은 퍼즐에 사용될 `9`개의 조각을 저장한다
`puzzle` 은 `3 * 3` 

백트래킹 과정에서 여러 함수가 동일한 퍼즐 상태에 접근해야 하므로, 전역 변수로 선언하여 매개변수 전달의 복잡성을 줄였다
`puzzle` 배열은 실제 조각 객체가 아닌 포인터를 저장하여 메모리 사용을 줄이고 조각 배치/제거 시 객체 복사 없이 포인터 할당만으로 처리할 수 있다

### 퍼즐 입력 방법

퍼즐 텍스트열 구성법에 따라 변환된 그림(`9 * 4` 표식)을 콘솔 입력으로 받는다
아래와 같이 작동한다

1. 한 줄 입력 받음
2. `4`개 표식으로 `set_state` 를 이용해 `piece_arr` 의 상태 초기화
3. `9`번 반복하며 `piece_arr` 의 모든 원소의 상태 초기화

따라서 `piece_arr`에 사용할 `9`개의 조각의 상태가 입력 텍스트 열에 의해 채워진다

### 퍼즐 출력 방법

각 퍼즐 조각의 번호와 회전 상태 표시
각 조각의 네 방향(북, 서, 남, 동)에 있는 표식 출력
퍼즐 조각 간의 경계와 여백을 `ASCII` 아트로 표현

#### 퍼즐 콘솔 입출력 예시

(예시 입력)

### 백트래킹 전략

퍼즐은 모든 경우의 수를 봐야하므로 백트래킹을 사용한다

### 퍼즐의 상태 공간 트리

퍼즐 문제의 상태 공간 트리는 다음과 같은 특징을 가진다

1. **루트 노드** : 빈 퍼즐 보드 (아직 조각이 배치되지 않은 상태)
2. **내부 노드** : 일부 위치에 조각이 배치된 부분 해
3. **리프 노드** : 모든 위치에 조각이 배치된 완전한 해 또는 더 이상 진행할 수 없는 상태
4. **간선**     : 조각 배치 또는 회전 등의 상태 전이

퍼즐 조각은 `4`개의 회전 상태를 가지고 조각은 `9`개이므로
각 노드에서는 다음과 같은 선택이 가능하다
- 어떤 조각을 선택할 것인가? (9개 조각 중 아직 사용하지 않은 조각)
- 선택한 조각을 어떻게 회전시킬 것인가? (4가지 회전 상태)

따라서 각 노드에서 최대 `36`개의 자식 노드가 가능하며, 트리의 깊이는 9(퍼즐 보드의 위치 수)이다

```
노드 = [보드 좌표 : 조각 번호 : 회전상태]
보드 좌표 = (i, k) [0 <= i, k <= 8]
조각 번호 = n [0 <= n <= 8]
회전 상태 = s [0 <= s <= 3]

                            [루트 = 빈 보드]
                      /       |            \        \
           [(0,0):1:0] [(0,0):1:1] ... [(0,0):5:2]..[(0,0):8:3]
              /   \
   [(0,1):0:0]... [(0,1):8:3] .....
```

퍼즐의 제한 없는 모든 가능한 경우의 수는 $4^9 \cdot 9!$ 이다 즉 리프노드도 그만큼 되므로 일반적으로 다 보기는 어렵다
따라서 `promising`개념을 사용해 상태공간 트리를 가지치기 한다
# 퍼즐 백트래킹 풀이 보고서

## 목차
1. [서론](#서론)
2. [퍼즐 모델링 방법 및 텍스트 표현](#퍼즐-모델링-방법-및-텍스트-표현)
3. [풀이 코드 분석](#풀이-코드-분석)
4. [프로그램 상의 퍼즐 표현 방법](#프로그램-상의-퍼즐-표현-방법)
5. [백트래킹 알고리즘 적용 및 상태공간트리](#백트래킹-알고리즘-적용-및-상태공간트리)
6. [시간복잡도 분석](#시간복잡도-분석)
7. [결론](#결론)

## 서론

본 보고서는 3x3 퍼즐 문제를 백트래킹 알고리즘을 사용하여 해결하는 방법에 대해 설명합니다. 퍼즐은 9개의 조각으로 구성되어 있으며, 각 조각은 네 방향(북, 서, 남, 동)에 그림이 있습니다. 이 그림들이 인접한 조각의 그림과 맞아떨어져야 퍼즐이 완성됩니다.

본 보고서에서는 퍼즐의 텍스트 모델링 방법, 코드 구조 및 알고리즘 설명, 프로그램 상의 퍼즐 표현 방법, 백트래킹 알고리즘의 적용 및 상태공간트리, 그리고 시간복잡도 분석을 다룹니다.

## 퍼즐 모델링 방법 및 텍스트 표현

### 퍼즐의 기본 구조

제공된 퍼즐은 3x3 크기의 격자로 구성되어 있으며, 각 칸에는 퍼즐 조각이 배치됩니다. 각 퍼즐 조각은 네 방향(북, 서, 남, 동)에 그림이 있으며, 이 그림들이 인접한 조각의 그림과 맞아떨어져야 퍼즐이 완성됩니다.

### 그림 종류와 분할 방식

#### 그림 종류
퍼즐에는 총 4종류의 그림이 사용되며, 이를 알파벳 A, B, C, D로 모델링하였습니다.

#### 분할 방식
각 그림은 두 가지 방식으로 분할될 수 있습니다:
1. **위/아래 분할**: 그림이 위쪽과 아래쪽으로 나뉘어집니다.
2. **좌/우 분할**: 그림이 왼쪽과 오른쪽으로 나뉘어집니다.

### 16가지 표식 체계

그림 4종류(A, B, C, D)와 분할 방식 2가지(위/아래, 좌/우)를 조합하면 총 16가지의 서로 다른 표식이 가능합니다. 이를 텍스트로 모델링하기 위해 다음과 같은 표기법을 사용합니다:

1. 그림 종류는 알파벳(A, B, C, D)으로 표시
2. 분할 방식과 위치는 특수 기호로 표시:
   - 위/아래 분할의 위쪽: `+`
   - 위/아래 분할의 아래쪽: `-`
   - 좌/우 분할의 왼쪽: `/`
   - 좌/우 분할의 오른쪽: `*`

따라서 16가지 표식은 다음과 같이 구성됩니다:
- A+, A-, A/, A*
- B+, B-, B/, B*
- C+, C-, C/, C*
- D+, D-, D/, D*

### 퍼즐 텍스트열 구성법

퍼즐의 각 조각은 4개의 방향(북, 서, 남, 동)을 가지며, 각 방향에는 위에서 설명한 16가지 표식 중 하나가 배치됩니다. 퍼즐 조각들을 텍스트로 표현할 때는 다음과 같은 규칙을 따릅니다:

1. 각 퍼즐 조각은 한 줄로 표현됩니다.
2. 한 줄에는 4개의 표식이 순서대로 나열됩니다(북, 서, 남, 동 방향 순).
3. 각 표식은 그림 종류(알파벳)와 분할 기호로 구성됩니다.

예를 들어, test.txt 파일에 있는 첫 번째 퍼즐의 첫 번째 조각은 다음과 같이 표현됩니다:
```
A* B* B/ C*
```

이는 다음을 의미합니다:
- 북쪽 방향: A* (A 그림의 오른쪽 부분)
- 서쪽 방향: B* (B 그림의 오른쪽 부분)
- 남쪽 방향: B/ (B 그림의 왼쪽 부분)
- 동쪽 방향: C* (C 그림의 오른쪽 부분)

### 퍼즐 매칭 규칙

퍼즐 조각들이 서로 맞아떨어지기 위해서는 인접한 두 조각의 맞닿는 면에 있는 그림이 서로 보완적이어야 합니다. 보완적인 관계는 다음과 같습니다:

1. 그림 종류(알파벳)가 동일해야 합니다.
2. 분할 기호는 서로 보완적이어야 합니다:
   - `+`와 `-`는 서로 보완적입니다(위/아래 분할의 위쪽과 아래쪽).
   - `/`와 `*`는 서로 보완적입니다(좌/우 분할의 왼쪽과 오른쪽).

예를 들어:
- A+는 A-와 매칭됩니다.
- B/는 B*와 매칭됩니다.
- C+는 C-와 매칭됩니다.
- D/는 D*와 매칭됩니다.

이러한 규칙을 통해 퍼즐의 모든 조각이 올바르게 배치되었는지 확인할 수 있습니다.

## 풀이 코드 분석

### 코드 구조 개요

제공된 HW3_2020203090.cpp 코드는 백트래킹 알고리즘을 사용하여 3x3 퍼즐을 해결하는 프로그램입니다. 코드는 크게 다음과 같은 부분으로 구성되어 있습니다:

1. 상수 및 방향 정의
2. 퍼즐 조각 클래스 정의
3. 전역 변수 선언
4. 퍼즐 조각 매칭 검사 함수
5. 백트래킹 알고리즘 구현
6. 입력 처리 함수
7. 퍼즐 출력 함수
8. 메인 함수

각 부분의 역할과 구현 방식을 상세히 살펴보겠습니다.

### 상수 및 방향 정의

```cpp
constexpr size_t N = 0;
constexpr size_t W = 1;
constexpr size_t S = 2;
constexpr size_t E = 3;

constexpr size_t PUZ_ROW = 3;
constexpr size_t PUZ_COL = 3;

constexpr size_t PIECE_COUNT = 9;
constexpr size_t PAINT_COUNT = 16;
constexpr size_t PAINT_TYPE = 2;
constexpr size_t PAINT_CONTAIN = 4;
constexpr size_t SHIFT_TYPE = 4;
```

이 부분에서는 프로그램에서 사용할 상수들을 정의합니다:
- `N`, `W`, `S`, `E`: 퍼즐 조각의 네 방향(북, 서, 남, 동)을 나타내는 인덱스
- `PUZ_ROW`, `PUZ_COL`: 퍼즐의 행과 열 크기(3x3)
- `PIECE_COUNT`: 퍼즐 조각의 총 개수(9개)
- `PAINT_COUNT`: 가능한 표식의 총 개수(16가지)
- `PAINT_TYPE`: 각 표식의 구성 요소 수(알파벳과 기호, 2개)
- `PAINT_CONTAIN`: 각 조각이 가진 방향의 수(4방향)
- `SHIFT_TYPE`: 회전 가능한 방향의 수(90도씩 4방향)

### 퍼즐 조각 클래스 정의

```cpp
class piece
{
public:
    piece() :shift_count{ 0 } {}

    void set_number(int n) { number = n; }

    void set_state(int s_idx, char first, char second)
    {
        for (size_t shift = 0; shift < SHIFT_TYPE; shift += 1)
        {
            size_t col = (s_idx + shift) % PAINT_CONTAIN;
            state[shift][col][0] = first;
            state[shift][col][1] = second;
        }
    }

    int get_number() const { return number; }
    size_t get_shift_count() const { return shift_count; }
    const array<char, PAINT_TYPE>& get_state(size_t direction) const
    {
        return state[shift_count][direction];
    }

    void shift() { shift_count = (shift_count + 1) % SHIFT_TYPE; }
private:
    int number;
    size_t shift_count;
    array<array<array<char, PAINT_TYPE>, PAINT_CONTAIN>, SHIFT_TYPE> state;
};
```

`piece` 클래스는 퍼즐 조각을 표현합니다:
- `number`: 조각의 번호
- `shift_count`: 현재 회전 상태(0~3)
- `state`: 조각의 상태를 저장하는 3차원 배열
  - 첫 번째 차원: 회전 상태(0~3)
  - 두 번째 차원: 방향(북, 서, 남, 동)
  - 세 번째 차원: 표식 구성 요소(알파벳과 기호)

주요 메서드:
- `set_number()`: 조각 번호 설정
- `set_state()`: 특정 방향의 표식 설정 및 회전 상태별 데이터 계산
- `get_number()`, `get_shift_count()`: 조각 번호와 현재 회전 상태 반환
- `get_state()`: 현재 회전 상태에서 특정 방향의 표식 반환
- `shift()`: 조각을 90도 회전(shift_count 증가)

### 전역 변수 선언

```cpp
array<piece, PIECE_COUNT> piece_arr;
array<array<piece*, PUZ_COL>, PUZ_ROW> puzzle;
```

- `piece_arr`: 9개의 퍼즐 조각을 저장하는 배열
- `puzzle`: 3x3 퍼즐 보드를 표현하는 2차원 배열(각 요소는 퍼즐 조각에 대한 포인터)

### 퍼즐 조각 매칭 검사 함수

```cpp
bool piece_pair_promising(const array<char, PAINT_TYPE>& a, const array<char, PAINT_TYPE>& b)
{
    if (a[0] != b[0]) return false;
    bool check = (a[1] == '+' && b[1] == '-') ||
                 (a[1] == '-' && b[1] == '+') ||
                 (a[1] == '*' && b[1] == '/') ||
                 (a[1] == '/' && b[1] == '*');
    return check;
}
```

`piece_pair_promising` 함수는 두 표식이 서로 매칭되는지 검사합니다:
1. 두 표식의 그림 종류(알파벳)가 동일한지 확인
2. 분할 기호가 서로 보완적인지 확인:
   - `+`와 `-`는 서로 보완적(위/아래 분할)
   - `*`와 `/`는 서로 보완적(좌/우 분할)

```cpp
bool puzzle_piece_promising(piece* target, int num)
{
    //처음은 그냥 통과
    if (num == 0) return true;

    //들어가는 퍼즐 조각 - target 기준
    //target의 좌표
    size_t row = num / 3, col = num % 3;

    //왼쪽만 보면 되는 경우
    if (num == 1 || num == 2)
    {
        piece* compare = puzzle[row][col - 1];
        return piece_pair_promising(target->get_state(W), compare->get_state(E));
    }
    //위쪽만 보면 되는 경우
    else if (num == 3 || num == 6)
    {
        piece* compare = puzzle[row - 1][col];
        return piece_pair_promising(target->get_state(N), compare->get_state(S));
    }
    //나머지는 왼쪽, 위쪽 다 봐야함
    else
    {
        piece* compare1 = puzzle[row][col - 1];
        piece* compare2 = puzzle[row - 1][col];
        return piece_pair_promising(target->get_state(W), compare1->get_state(E)) &&
               piece_pair_promising(target->get_state(N), compare2->get_state(S));
    }
}
```

`puzzle_piece_promising` 함수는 특정 위치에 퍼즐 조각을 배치할 수 있는지 검사합니다:
1. 첫 번째 위치(0)는 항상 배치 가능
2. 위치에 따라 검사해야 할 인접 조각이 다름:
   - 첫 번째 행의 두 번째, 세 번째 위치(1, 2): 왼쪽 조각만 검사
   - 두 번째, 세 번째 행의 첫 번째 위치(3, 6): 위쪽 조각만 검사
   - 나머지 위치(4, 5, 7, 8): 왼쪽과 위쪽 조각 모두 검사

### 백트래킹 알고리즘 구현

```cpp
bool backtracking(int puzzle_num, int remain_piece)
{
    //해 완성되면 탈출
    if (puzzle_num == 9) return true;

    //남은 조각들에 대해(비트 마스크 사용)
    for (int p_i = 0; p_i < PIECE_COUNT; p_i += 1)
        if (remain_piece & (1 << p_i))
        {
            //조각 promising 검사 후 대입
            piece* now = &piece_arr[p_i];
            size_t row = puzzle_num / 3, col = puzzle_num % 3;
            //회전 고려(회전 4번해서 원 상태로 만듬)
            for (int shift = 0; shift < 4; shift += 1)
            {
                if (puzzle_piece_promising(now, puzzle_num))
                {
                    //해 할당
                    puzzle[row][col] = now;
                    //해당하는 해 하나만 보임
                    int mask = remain_piece & ~(1 << p_i);
                    if (backtracking(puzzle_num + 1, mask)) return true;
                    //상태 원복 (여기 오면 들어간 곳이 해가 없다는 뜻이므로)
                    puzzle[row][col] = nullptr;
                }
                now->shift();
            }
        }

    //여기로 오면 해가 없는것
    return false;
}
```

`backtracking` 함수는 백트래킹 알고리즘을 구현합니다:
1. 기저 조건: 모든 위치(9개)에 조각을 배치했으면 성공(true 반환)
2. 남은 조각들에 대해 반복(비트마스크로 사용 가능한 조각 관리):
   - 각 조각에 대해 4가지 회전 상태 모두 시도
   - 조각이 현재 위치에 배치 가능한지 검사(`puzzle_piece_promising`)
   - 배치 가능하면 조각을 배치하고 다음 위치로 재귀 호출
   - 재귀 호출이 성공하면 true 반환
   - 실패하면 조각 제거(백트래킹) 후 다른 조각/회전 시도
3. 모든 조합을 시도해도 해결책을 찾지 못하면 false 반환

### 입력 처리 함수

```cpp
void input_process()
{
    string prompt = /* 생략 */;
    std::cout << prompt;

    string input;
    istringstream iss;
    string token;
    
    for (size_t p = 0; p < PIECE_COUNT; p += 1)
    {
        getline(cin, input);
        iss.clear();
        iss.str(input);
        piece_arr[p].set_number(p);

        for (size_t i = 0; i < PAINT_CONTAIN; i += 1)
        {
            iss >> token;
            piece_arr[p].set_state(i, token[0], token[1]);
        }
    }
}
```

`input_process` 함수는 사용자로부터 퍼즐 조각 정보를 입력받습니다:
1. 입력 형식에 대한 안내 메시지 출력
2. 9개의 퍼즐 조각에 대해 반복:
   - 한 줄 입력 받기
   - 각 조각의 번호 설정
   - 4개 방향(북, 서, 남, 동)의 표식 정보 파싱 및 설정

### 퍼즐 출력 함수

```cpp
void print_puzzle()
{
    std::cout << "\n퍼즐 \n(a,b) = (퍼즐 번호, 반시계 90도 회전한 횟수)\n\n";

    const piece* p;
    array<char, 2> s;

    for (int row = 0; row < 3; ++row)
    {
        // 첫 줄: 북쪽 방향
        for (int col = 0; col < 3; ++col)
        {
            p = puzzle[row][col];
            s = p->get_state(N);
            std::cout << "--- " << s[0] << s[1] << "  --- ";
        }
        std::cout << "\n";

        // 둘째 줄: 위쪽 여백
        for (int col = 0; col < 3; ++col)
            std::cout << "|         | ";
        std::cout << "\n";

        // 셋째 줄: 서쪽, 번호/시프트, 동쪽
        for (int col = 0; col < 3; ++col)
        {
            p = puzzle[row][col];
            s = p->get_state(W);
            std::cout << s[0] << s[1] << " (" << p->get_number() << "," << p->get_shift_count() << ") ";
            s = p->get_state(E);
            std::cout << s[0] << s[1] << " ";
        }
        std::cout << "\n";

        // 넷째 줄: 아래쪽 여백
        for (int col = 0; col < 3; ++col)
            std::cout << "|         | ";
        std::cout << "\n";

        // 다섯째 줄: 남쪽 방향
        for (int col = 0; col < 3; ++col)
        {
            p = puzzle[row][col];
            s = p->get_state(S);
            std::cout << "--- " << s[0] << s[1] << "  --- ";
        }
        std::cout << "\n";
    }
}
```

`print_puzzle` 함수는 현재 퍼즐 상태를 시각적으로 출력합니다:
1. 각 퍼즐 조각의 번호와 회전 상태 표시
2. 각 조각의 네 방향(북, 서, 남, 동)에 있는 표식 출력
3. 퍼즐 조각 간의 경계와 여백을 ASCII 아트로 표현

```cpp
void print_test()
{
    for (size_t r = 0; r < PUZ_ROW; r += 1)
        for (size_t c = 0; c < PUZ_COL; c += 1)
        {
            puzzle[r][c] = &piece_arr[PUZ_COL * r + c];
        }

    print_puzzle();

    for (size_t r = 0; r < PUZ_ROW; r += 1)
        for (size_t c = 0; c < PUZ_COL; c += 1)
        {
            puzzle[r][c] = nullptr;
        }
}
```

`print_test` 함수는 입력된 퍼즐 조각들을 초기 순서대로 배치하여 출력한 후, 퍼즐 보드를 초기화합니다.

### 메인 함수

```cpp
int main()
{
    input_process();
    std::cout << "\n입력 퍼즐 표시\n";
    print_test();
    
    int init = 511;
    if (backtracking(0, init))
    {
        std::cout << "\n퍼즐 풀이\n";
        print_puzzle();
    }
    else
    {
        std::cout << "\n해가 없다\n" << endl;
    }

    
    return 0;
}
```

메인 함수는 프로그램의 전체 흐름을 제어합니다:
1. 퍼즐 조각 정보 입력 받기
2. 입력된 퍼즐 조각들을 초기 순서대로 출력
3. 백트래킹 알고리즘으로 퍼즐 해결 시도:
   - `init = 511`은 비트마스크로, 9개 조각 모두 사용 가능함을 의미(2^9 - 1 = 511)
   - 백트래킹 성공 시 해결된 퍼즐 출력
   - 실패 시 해결책 없음 메시지 출력

## 프로그램 상의 퍼즐 표현 방법

### 자료구조 선택 이유

퍼즐 문제를 효과적으로 해결하기 위해 코드에서는 다음과 같은 자료구조를 선택했습니다:

#### 1. `piece` 클래스

퍼즐 조각을 표현하기 위해 객체 지향적 접근 방식을 채택하여 `piece` 클래스를 정의했습니다. 이 선택의 주요 이유는:

- **캡슐화**: 퍼즐 조각의 상태와 동작을 하나의 단위로 묶어 관리할 수 있습니다.
- **회전 처리 용이성**: 조각의 회전 상태를 내부적으로 관리하여 외부에서는 간단히 `shift()` 메서드만 호출하면 됩니다.
- **상태 접근 일관성**: `get_state()` 메서드를 통해 현재 회전 상태에 맞는 방향 정보를 자동으로 제공합니다.

#### 2. 다차원 배열 사용

퍼즐 조각의 상태를 저장하기 위해 3차원 배열을 사용했습니다:
```cpp
array<array<array<char, PAINT_TYPE>, PAINT_CONTAIN>, SHIFT_TYPE> state;
```

이 구조의 선택 이유:
- **효율적인 회전 처리**: 회전된 모든 상태를 미리 계산하여 저장함으로써 실행 시간에 회전 계산을 반복하지 않아도 됩니다.
- **상수 시간 접근**: 특정 회전 상태와 방향의 표식에 O(1) 시간에 접근할 수 있습니다.
- **메모리 효율성**: 퍼즐 조각 수가 적고 각 조각의 상태 정보가 작기 때문에, 모든 가능한 상태를 미리 저장해도 메모리 사용량이 크지 않습니다.

#### 3. 전역 배열 사용

퍼즐 조각과 퍼즐 보드를 표현하기 위해 전역 배열을 사용했습니다:
```cpp
array<piece, PIECE_COUNT> piece_arr;
array<array<piece*, PUZ_COL>, PUZ_ROW> puzzle;
```

이 선택의 이유:
- **함수 간 상태 공유**: 백트래킹 과정에서 여러 함수가 동일한 퍼즐 상태에 접근해야 하므로, 전역 변수로 선언하여 매개변수 전달의 복잡성을 줄였습니다.
- **포인터 사용 효율성**: `puzzle` 배열은 실제 조각 객체가 아닌 포인터를 저장하여 메모리 사용을 최적화하고, 조각 배치/제거 시 객체 복사 없이 포인터 할당만으로 처리할 수 있습니다.

#### 4. 비트마스크 사용

백트래킹 과정에서 사용 가능한 조각을 추적하기 위해 비트마스크를 사용했습니다:
```cpp
int init = 511; // 2^9 - 1, 모든 9개 조각이 사용 가능함을 의미
```

이 선택의 이유:
- **공간 효율성**: 9개 조각의 사용 여부를 9개의 비트로 표현하여 메모리 사용을 최소화합니다.
- **연산 효율성**: 비트 연산을 통해 조각 사용/해제 상태를 빠르게 업데이트할 수 있습니다.
- **코드 간결성**: 복잡한 배열이나 집합 대신 단일 정수로 상태를 관리할 수 있습니다.

### 퍼즐 상태 표현 방식

#### 1. 퍼즐 조각 표현

각 퍼즐 조각은 다음 정보를 포함합니다:
- **번호(number)**: 조각의 고유 식별자(0~8)
- **회전 상태(shift_count)**: 현재 회전 각도(0~3, 각각 0°, 90°, 180°, 270° 회전을 의미)
- **표식 정보(state)**: 모든 회전 상태와 방향에 대한 표식 정보

표식 정보는 3차원 배열로 구성됩니다:
```cpp
array<array<array<char, PAINT_TYPE>, PAINT_CONTAIN>, SHIFT_TYPE> state;
```

- 첫 번째 차원(SHIFT_TYPE=4): 회전 상태(0°, 90°, 180°, 270°)
- 두 번째 차원(PAINT_CONTAIN=4): 방향(북, 서, 남, 동)
- 세 번째 차원(PAINT_TYPE=2): 표식 구성 요소(그림 종류와 분할 기호)

이 구조를 통해 조각을 회전시킬 때마다 실제 데이터를 재배치할 필요 없이, 단순히 `shift_count`를 증가시키는 것만으로 회전된 상태를 표현할 수 있습니다.

#### 2. 퍼즐 보드 표현

3x3 퍼즐 보드는 다음과 같이 표현됩니다:
```cpp
array<array<piece*, PUZ_COL>, PUZ_ROW> puzzle;
```

이 2차원 배열의 각 요소는 퍼즐 조각에 대한 포인터입니다. 이 방식의 장점:
- **NULL 포인터 활용**: 아직 조각이 배치되지 않은 위치는 NULL 포인터로 표시
- **효율적인 배치/제거**: 조각 배치는 포인터 할당으로, 제거는 NULL 할당으로 간단히 처리
- **원본 데이터 참조**: 포인터를 통해 `piece_arr`의 원본 조각 객체를 직접 참조하므로 데이터 중복 없음

#### 3. 퍼즐 상태 변화 표현

백트래킹 과정에서 퍼즐 상태는 다음과 같이 변화합니다:

1. **조각 선택**: 사용 가능한 조각 중 하나를 선택
   ```cpp
   piece* now = &piece_arr[p_i];
   ```

2. **회전 시도**: 선택한 조각의 4가지 회전 상태를 모두 시도
   ```cpp
   for (int shift = 0; shift < 4; shift += 1) {
       // 회전 상태 검사
       now->shift(); // 다음 회전 상태로 변경
   }
   ```

3. **조각 배치**: 유망한 경우 조각을 퍼즐 보드에 배치
   ```cpp
   puzzle[row][col] = now;
   ```

4. **사용 가능 조각 업데이트**: 비트마스크를 사용하여 배치한 조각을 사용 불가능으로 표시
   ```cpp
   int mask = remain_piece & ~(1 << p_i);
   ```

5. **백트래킹**: 현재 경로가 해결책으로 이어지지 않으면 조각 제거 및 다른 경로 시도
   ```cpp
   puzzle[row][col] = nullptr;
   ```

이러한 상태 표현 방식은 백트래킹 알고리즘의 효율적인 구현을 가능하게 하며, 퍼즐의 상태 변화를 명확하고 간결하게 관리할 수 있게 합니다.

## 백트래킹 알고리즘 적용 및 상태공간트리

### 백트래킹 알고리즘의 개요

백트래킹(Backtracking)은 해를 찾는 도중에 막히면(즉, 해가 아니면) 되돌아가서 다시 해를 찾아가는 알고리즘입니다. 이 알고리즘은 모든 가능한 경우의 수를 탐색하되, 유망하지 않은 경로는 조기에 차단(가지치기)하여 탐색 공간을 줄이는 방식으로 동작합니다.

퍼즐 문제에서 백트래킹은 다음과 같은 특징을 가집니다:
1. **점진적 해 구성**: 퍼즐 보드의 각 위치에 조각을 하나씩 배치하며 해를 구성
2. **유망성 검사**: 각 단계에서 현재까지의 부분 해가 유망한지 검사
3. **가지치기**: 유망하지 않은 경로는 더 이상 탐색하지 않음
4. **되돌아가기**: 현재 경로가 해결책으로 이어지지 않으면 이전 단계로 되돌아감

### 퍼즐 문제에서의 백트래킹 적용

제공된 코드에서 백트래킹 알고리즘은 `backtracking` 함수에 구현되어 있습니다:

```cpp
bool backtracking(int puzzle_num, int remain_piece)
{
    //해 완성되면 탈출
    if (puzzle_num == 9) return true;

    //남은 조각들에 대해(비트 마스크 사용)
    for (int p_i = 0; p_i < PIECE_COUNT; p_i += 1)
        if (remain_piece & (1 << p_i))
        {
            //조각 promising 검사 후 대입
            piece* now = &piece_arr[p_i];
            size_t row = puzzle_num / 3, col = puzzle_num % 3;
            //회전 고려(회전 4번해서 원 상태로 만듬)
            for (int shift = 0; shift < 4; shift += 1)
            {
                if (puzzle_piece_promising(now, puzzle_num))
                {
                    //해 할당
                    puzzle[row][col] = now;
                    //해당하는 해 하나만 보임
                    int mask = remain_piece & ~(1 << p_i);
                    if (backtracking(puzzle_num + 1, mask)) return true;
                    //상태 원복 (여기 오면 들어간 곳이 해가 없다는 뜻이므로)
                    puzzle[row][col] = nullptr;
                }
                now->shift();
            }
        }

    //여기로 오면 해가 없는것
    return false;
}
```

이 함수는 다음과 같은 방식으로 백트래킹을 구현합니다:

1. **기저 조건**: `puzzle_num == 9`일 때, 즉 모든 9개 위치에 조각을 배치했을 때 성공(true 반환)
2. **후보 선택**: 아직 사용하지 않은 조각들 중에서 하나를 선택
3. **유망성 검사**: 선택한 조각이 현재 위치에 배치 가능한지 검사(`puzzle_piece_promising`)
4. **해 확장**: 유망하면 조각을 배치하고 다음 위치로 재귀 호출
5. **백트래킹**: 현재 경로가 해결책으로 이어지지 않으면 조각을 제거하고 다른 조각/회전 시도

### 상태공간트리 구조

상태공간트리(State Space Tree)는 문제 해결 과정에서 가능한 모든 상태와 그 상태 간의 전이를 나타내는 트리 구조입니다. 퍼즐 문제의 상태공간트리는 다음과 같은 특징을 가집니다:

1. **루트 노드**: 빈 퍼즐 보드(아직 조각이 배치되지 않은 상태)
2. **내부 노드**: 일부 위치에 조각이 배치된 부분 해
3. **리프 노드**: 모든 위치에 조각이 배치된 완전한 해 또는 더 이상 진행할 수 없는 상태
4. **간선**: 조각 배치 또는 회전 등의 상태 전이

퍼즐 문제의 상태공간트리는 다음과 같은 구조를 가집니다:

```
                       [빈 보드]
                      /    |    \
           [위치0:조각0] [위치0:조각1] ... [위치0:조각8]
              /   \
[위치0:조각0,위치1:조각1] ... [위치0:조각0,위치1:조각8]
              ...
```

각 노드에서는 다음과 같은 선택이 가능합니다:
- 어떤 조각을 선택할 것인가? (9개 조각 중 아직 사용하지 않은 조각)
- 선택한 조각을 어떻게 회전시킬 것인가? (4가지 회전 상태)

따라서 각 노드에서 최대 9×4=36개의 자식 노드가 가능하며, 트리의 깊이는 9(퍼즐 보드의 위치 수)입니다.

### 가지치기 전략

가지치기(Pruning)는 유망하지 않은 경로를 조기에 차단하여 탐색 공간을 줄이는 전략입니다. 제공된 코드에서는 다음과 같은 가지치기 전략을 사용합니다:

#### 1. 유망성 검사를 통한 가지치기

`puzzle_piece_promising` 함수는 현재 위치에 조각을 배치할 수 있는지 검사합니다:

```cpp
bool puzzle_piece_promising(piece* target, int num)
{
    //처음은 그냥 통과
    if (num == 0) return true;

    //들어가는 퍼즐 조각 - target 기준
    //target의 좌표
    size_t row = num / 3, col = num % 3;

    //왼쪽만 보면 되는 경우
    if (num == 1 || num == 2)
    {
        piece* compare = puzzle[row][col - 1];
        return piece_pair_promising(target->get_state(W), compare->get_state(E));
    }
    //위쪽만 보면 되는 경우
    else if (num == 3 || num == 6)
    {
        piece* compare = puzzle[row - 1][col];
        return piece_pair_promising(target->get_state(N), compare->get_state(S));
    }
    //나머지는 왼쪽, 위쪽 다 봐야함
    else
    {
        piece* compare1 = puzzle[row][col - 1];
        piece* compare2 = puzzle[row - 1][col];
        return piece_pair_promising(target->get_state(W), compare1->get_state(E)) &&
               piece_pair_promising(target->get_state(N), compare2->get_state(S));
    }
}
```

이 함수는 위치에 따라 다음과 같은 검사를 수행합니다:
- 첫 번째 위치(0): 항상 유망함(어떤 조각이든 배치 가능)
- 첫 번째 행의 두 번째, 세 번째 위치(1, 2): 왼쪽 조각과의 매칭만 검사
- 두 번째, 세 번째 행의 첫 번째 위치(3, 6): 위쪽 조각과의 매칭만 검사
- 나머지 위치(4, 5, 7, 8): 왼쪽과 위쪽 조각 모두와의 매칭 검사

조각 간의 매칭은 `piece_pair_promising` 함수에서 검사합니다:

```cpp
bool piece_pair_promising(const array<char, PAINT_TYPE>& a, const array<char, PAINT_TYPE>& b)
{
    if (a[0] != b[0]) return false;
    bool check = (a[1] == '+' && b[1] == '-') ||
                 (a[1] == '-' && b[1] == '+') ||
                 (a[1] == '*' && b[1] == '/') ||
                 (a[1] == '/' && b[1] == '*');
    return check;
}
```

이 함수는 두 표식이 매칭되는지 검사합니다:
1. 그림 종류(알파벳)가 동일한지 확인
2. 분할 기호가 서로 보완적인지 확인:
   - `+`와 `-`는 서로 보완적(위/아래 분할)
   - `*`와 `/`는 서로 보완적(좌/우 분할)

유망성 검사를 통해 다음과 같은 가지치기가 이루어집니다:
- 인접한 조각과 매칭되지 않는 조각은 배치하지 않음
- 유망하지 않은 경로는 더 이상 탐색하지 않음

#### 2. 비트마스크를 통한 사용 가능 조각 관리

백트래킹 함수에서는 비트마스크를 사용하여 사용 가능한 조각을 관리합니다:

```cpp
int init = 511; // 2^9 - 1, 모든 9개 조각이 사용 가능함을 의미
```

각 재귀 호출에서 사용한 조각을 비트마스크에서 제거합니다:

```cpp
int mask = remain_piece & ~(1 << p_i);
if (backtracking(puzzle_num + 1, mask)) return true;
```

이를 통해 다음과 같은 가지치기가 이루어집니다:
- 이미 사용한 조각은 다시 사용하지 않음
- 각 조각은 정확히 한 번만 사용됨

#### 3. 조기 성공 반환

백트래킹 함수에서는 해결책을 찾으면 즉시 성공을 반환합니다:

```cpp
if (backtracking(puzzle_num + 1, mask)) return true;
```

이를 통해 다음과 같은 가지치기가 이루어집니다:
- 첫 번째 해결책을 찾으면 더 이상 탐색하지 않음
- 불필요한 추가 탐색을 방지하여 실행 시간 단축

### 백트래킹 알고리즘의 실행 흐름

퍼즐 문제에서 백트래킹 알고리즘의 실행 흐름은 다음과 같습니다:

1. **초기 호출**: `backtracking(0, 511)`
   - 첫 번째 위치(0)부터 시작
   - 모든 조각(9개)이 사용 가능한 상태(비트마스크 511)

2. **첫 번째 위치 처리**:
   - 9개 조각 중 하나를 선택하여 첫 번째 위치에 배치
   - 각 조각에 대해 4가지 회전 상태 시도
   - 첫 번째 위치는 항상 유망함(어떤 조각이든 배치 가능)

3. **두 번째 위치 처리**:
   - 남은 8개 조각 중 하나를 선택하여 두 번째 위치에 배치
   - 각 조각에 대해 4가지 회전 상태 시도
   - 왼쪽 조각과 매칭되는지 검사(유망성 검사)
   - 유망하지 않으면 다른 조각/회전 시도

4. **이후 위치 처리**:
   - 위치에 따라 왼쪽, 위쪽, 또는 양쪽 모두와의 매칭 검사
   - 유망한 경우에만 다음 위치로 진행
   - 유망하지 않거나 해결책이 없으면 이전 위치로 되돌아감(백트래킹)

5. **종료 조건**:
   - 모든 9개 위치에 조각을 배치했으면 성공(true 반환)
   - 모든 가능한 조합을 시도해도 해결책을 찾지 못하면 실패(false 반환)

이러한 백트래킹 과정을 통해 퍼즐의 해결책을 효율적으로 찾을 수 있습니다.

## 시간복잡도 분석

### 이론적 시간복잡도

백트래킹 알고리즘의 최악의 경우 시간복잡도는 상태공간트리의 모든 노드를 탐색해야 하는 경우입니다:

- 퍼즐 보드의 위치 수: 9개 (3x3 보드)
- 각 위치에서의 선택지:
  - 첫 번째 위치: 9개 조각 × 4가지 회전 = 36가지
  - 두 번째 위치: 8개 조각 × 4가지 회전 = 32가지
  - ...
  - 마지막 위치: 1개 조각 × 4가지 회전 = 4가지

따라서 최악의 경우 시간복잡도는:
```
O(9! × 4^9)
```

이는 다음과 같이 계산됩니다:
- 9!: 9개 조각을 9개 위치에 배치하는 순열의 수
- 4^9: 각 조각이 4가지 회전 상태를 가질 수 있으므로, 9개 조각에 대해 4^9가지 회전 조합 가능

이 값은 약 9! × 2^18 ≈ 362,880 × 262,144 ≈ 9.5 × 10^10으로, 매우 큰 수입니다.

### 실제 시간복잡도

그러나 실제로는 가지치기 전략으로 인해 탐색 공간이 크게 줄어듭니다:

1. **유망성 검사**: 인접한 조각과 매칭되지 않는 조각은 즉시 제외됩니다. 이는 탐색 공간을 크게 줄이는 효과가 있습니다.

2. **조기 성공 반환**: 첫 번째 해결책을 찾으면 더 이상 탐색하지 않습니다.

3. **위치별 제약 조건**: 위치에 따라 검사해야 할 인접 조각이 다르며, 첫 번째 위치는 항상 유망하지만 이후 위치는 점점 더 많은 제약 조건을 가집니다.

이러한 가지치기 전략으로 인해 실제 시간복잡도는 최악의 경우보다 훨씬 낮습니다. 실험적으로는 대부분의 퍼즐이 수 초 내에 해결됩니다.

### 공간복잡도

공간복잡도는 알고리즘이 사용하는 메모리 양을 나타냅니다:

- **퍼즐 조각 저장**: O(PIECE_COUNT × SHIFT_TYPE × PAINT_CONTAIN × PAINT_TYPE) = O(9 × 4 × 4 × 2) = O(288)
- **퍼즐 보드 저장**: O(PUZ_ROW × PUZ_COL) = O(3 × 3) = O(9)
- **재귀 호출 스택**: O(PUZ_ROW × PUZ_COL) = O(9) (최대 재귀 깊이)

따라서 전체 공간복잡도는 O(288 + 9 + 9) = O(306)로, 상수 공간입니다.

### 최적화 가능성

현재 구현에서 추가적인 최적화 가능성:

1. **휴리스틱 적용**: 가장 제약이 많은 위치부터 채우는 방식으로 탐색 순서를 변경하면 더 빠르게 해결책을 찾을 수 있습니다.

2. **대칭성 고려**: 퍼즐의 대칭적 특성을 고려하여 중복 탐색을 줄일 수 있습니다.

3. **병렬 처리**: 독립적인 탐색 경로를 병렬로 처리하여 실행 시간을 단축할 수 있습니다.

## 결론

본 보고서에서는 3x3 퍼즐 문제를 백트래킹 알고리즘을 사용하여 해결하는 방법에 대해 설명했습니다. 퍼즐의 텍스트 모델링 방법, 코드 구조 및 알고리즘 설명, 프로그램 상의 퍼즐 표현 방법, 백트래킹 알고리즘의 적용 및 상태공간트리, 그리고 시간복잡도 분석을 다루었습니다.

퍼즐 문제는 그림 4종류와 2가지 분할 방식을 조합한 16가지 표식을 사용하여 모델링되었으며, 각 퍼즐 조각은 4개의 방향(북, 서, 남, 동)에 이러한 표식이 배치되어 있습니다. 퍼즐 조각들이 서로 맞아떨어지기 위해서는 인접한 두 조각의 맞닿는 면에 있는 그림이 서로 보완적이어야 합니다.

백트래킹 알고리즘은 퍼즐 보드의 각 위치에 조각을 하나씩 배치하며 해를 구성하고, 각 단계에서 현재까지의 부분 해가 유망한지 검사하여 유망하지 않은 경로는 더 이상 탐색하지 않는 방식으로 동작합니다. 이러한 가지치기 전략으로 인해 이론적으로는 매우 높은 시간복잡도를 가지지만, 실제 실행 시간은 크게 단축됩니다.

퍼즐 문제의 백트래킹 알고리즘은 객체 지향적 접근 방식, 다차원 배열, 포인터, 비트마스크 등 다양한 자료구조와 기법을 활용하여 효율적으로 구현되었습니다. 이러한 구현은 퍼즐의 상태 변화를 명확하고 간결하게 관리할 수 있게 하며, 백트래킹 알고리즘의 효율적인 실행을 가능하게 합니다.

결론적으로, 백트래킹 알고리즘은 퍼즐 문제와 같은 조합 최적화 문제를 해결하는 데 매우 효과적인 방법이며, 적절한 가지치기 전략을 통해 탐색 공간을 크게 줄일 수 있습니다.
